import os
import json
import subprocess
from datetime import datetime
from github import Github
from packaging import version
import toml
import requests
import logging

class DependencyUpdateNotifier:
    def __init__(self, github_token, repo_name, package_files=None):
        """
        Initialize the dependency update notifier.
        
        Args:
            github_token (str): GitHub personal access token
            repo_name (str): Repository name in format 'owner/repo'
            package_files (list): List of package files to check (default: ['requirements.txt', 'pyproject.toml'])
        """
        self.github = Github(github_token)
        self.repo = self.github.get_repo(repo_name)
        self.package_files = package_files or ['requirements.txt', 'pyproject.toml']
        
        # Set up logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s'
        )
        self.logger = logging.getLogger(__name__)

    def get_current_dependencies(self, file_path):
        """Parse dependency files and return current versions."""
        dependencies = {}
        
        try:
            if file_path.endswith('.txt'):
                with open(file_path, 'r') as f:
                    for line in f:
                        if '==' in line:
                            name, ver = line.strip().split('==')
                            dependencies[name] = ver
                            
            elif file_path.endswith('.toml'):
                with open(file_path, 'r') as f:
                    pyproject = toml.load(f)
                    # Handle both poetry and regular dependencies
                    deps = pyproject.get('tool', {}).get('poetry', {}).get('dependencies', {})
                    deps.update(pyproject.get('project', {}).get('dependencies', {}))
                    
                    for name, ver in deps.items():
                        if isinstance(ver, str):
                            # Handle version constraints like ^1.2.3 or ~2.3.4
                            ver = ver.replace('^', '').replace('~', '')
                            dependencies[name] = ver
                            
        except Exception as e:
            self.logger.error(f"Error parsing {file_path}: {str(e)}")
            
        return dependencies

    def get_latest_version(self, package_name):
        """Get the latest version of a package from PyPI."""
        try:
            response = requests.get(f"https://pypi.org/pypi/{package_name}/json")
            response.raise_for_status()
            return response.json()['info']['version']
        except Exception as e:
            self.logger.error(f"Error fetching version for {package_name}: {str(e)}")
            return None

    def create_github_issue(self, package_name, current_version, latest_version, file_path):
        """Create a GitHub issue for an outdated dependency."""
        title = f"Update {package_name} from {current_version} to {latest_version}"
        body = f"""
Dependency update notification:

- Package: `{package_name}`
- Current version: `{current_version}`
- Latest version: `{latest_version}`
- File: `{file_path}`

This issue was automatically generated by the Dependency Update Notifier.
        """
        
        try:
            issue = self.repo.create_issue(
                title=title,
                body=body,
                labels=['dependencies', 'update']
            )
            self.logger.info(f"Created issue #{issue.number} for {package_name}")
            return issue
        except Exception as e:
            self.logger.error(f"Error creating issue for {package_name}: {str(e)}")
            return None

    def create_pull_request(self, package_name, current_version, latest_version, file_path):
        """Create a pull request with the updated dependency."""
        branch_name = f"update-{package_name}-{latest_version}"
        
        try:
            # Get the default branch
            default_branch = self.repo.default_branch
            
            # Create a new branch
            ref = self.repo.get_git_ref(f"heads/{default_branch}")
            self.repo.create_git_ref(f"refs/heads/{branch_name}", ref.object.sha)
            
            # Update the dependency file
            file_content = self.repo.get_contents(file_path, ref=default_branch)
            content = file_content.decoded_content.decode()
            
            if file_path.endswith('.txt'):
                new_content = content.replace(
                    f"{package_name}=={current_version}",
                    f"{package_name}=={latest_version}"
                )
            elif file_path.endswith('.toml'):
                pyproject = toml.loads(content)
                if 'tool' in pyproject and 'poetry' in pyproject['tool']:
                    pyproject['tool']['poetry']['dependencies'][package_name] = f"^{latest_version}"
                if 'project' in pyproject and 'dependencies' in pyproject['project']:
                    pyproject['project']['dependencies'][package_name] = f"^{latest_version}"
                new_content = toml.dumps(pyproject)
            
            # Commit the changes
            self.repo.update_file(
                file_path,
                f"Update {package_name} to {latest_version}",
                new_content,
                file_content.sha,
                branch=branch_name
            )
            
            # Create pull request
            pr = self.repo.create_pull(
                title=f"Update {package_name} to {latest_version}",
                body=f"""
Automated dependency update pull request:

- Package: `{package_name}`
- Current version: `{current_version}`
- Latest version: `{latest_version}`
- File: `{file_path}`

This pull request was automatically generated by the Dependency Update Notifier.
                """,
                head=branch_name,
                base=default_branch
            )
            
            self.logger.info(f"Created PR #{pr.number} for {package_name}")
            return pr
            
        except Exception as e:
            self.logger.error(f"Error creating PR for {package_name}: {str(e)}")
            return None

    def check_dependencies(self, create_pr=False):
        """
        Check all dependencies for updates and create issues or pull requests.
        
        Args:
            create_pr (bool): If True, create pull requests instead of issues
        """
        for file_path in self.package_files:
            if not os.path.exists(file_path):
                self.logger.warning(f"File not found: {file_path}")
                continue
                
            self.logger.info(f"Checking dependencies in {file_path}")
            current_deps = self.get_current_dependencies(file_path)
            
            for package_name, current_version in current_deps.items():
                latest_version = self.get_latest_version(package_name)
                
                if not latest_version:
                    continue
                    
                try:
                    if version.parse(latest_version) > version.parse(current_version):
                        self.logger.info(f"Update available for {package_name}: {current_version} -> {latest_version}")
                        
                        if create_pr:
                            self.create_pull_request(
                                package_name,
                                current_version,
                                latest_version,
                                file_path
                            )
                        else:
                            self.create_github_issue(
                                package_name,
                                current_version,
                                latest_version,
                                file_path
                            )
                except Exception as e:
                    self.logger.error(f"Error comparing versions for {package_name}: {str(e)}")

def main():
    # Load configuration from environment variables or config file
    github_token = os.getenv('GITHUB_TOKEN')
    repo_name = os.getenv('GITHUB_REPOSITORY')
    
    if not github_token or not repo_name:
        raise ValueError("GITHUB_TOKEN and GITHUB_REPOSITORY environment variables are required")
    
    updater = DependencyUpdateNotifier(github_token, repo_name)
    updater.check_dependencies(create_pr=True)

if __name__ == "__main__":
    main()
